<!DOCTYPE html>
<html>
<head>
    <title>Bounce Transition Demo</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Bouncing sphere wireframe
        const sphere = (() => {
            const geometry = new THREE.SphereGeometry(1.3, 25, 18);
            const edges = new THREE.EdgesGeometry(geometry);
            return new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: true
                })
            );
        })();

        // Camera wireframe
        const cameraWireframe = (() => {
            const group = new THREE.Group();
            
            // Camera body
            const bodyGeometry = new THREE.BoxGeometry(1.9, 1.8, 1.9);
            const bodyEdges = new THREE.EdgesGeometry(bodyGeometry);
            const bodyLines = new THREE.LineSegments(
                bodyEdges,
                new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true })
            );

            // Lens
            const lensGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.6, 20);
            const lensEdges = new THREE.EdgesGeometry(lensGeometry);
            const lensLines = new THREE.LineSegments(
                lensEdges,
                new THREE.LineBasicMaterial({ color: 0xffffff })
            );
            lensLines.rotation.x = Math.PI/2;
            lensLines.position.z = 0.8;

            // Buttons
            const addButton = (x, y, z) => {
                const geometry = new THREE.CylinderGeometry(0.1, 0.1, -0.00, 8);
                const edges = new THREE.EdgesGeometry(geometry);
                const button = new THREE.LineSegments(
                    edges,
                    new THREE.LineBasicMaterial({ color: 0xffffff })
                );
                button.rotation.x = Math.PI/2;
                button.position.set(x, y, z);
                return button;
            };

            group.add(bodyLines, lensLines,
                addButton(0.5, 0.5, 0.6),
                addButton(-0.5, 0.5, 0.6),
                addButton(0, -0.5, 0.6)
            );
            return group;
        })();

        // Suitcase wireframe
        const suitcaseWireframe = (() => {
    const group = new THREE.Group();
    
    // Main body (vertical cuboid: height > width)
    const bodyGeometry = new THREE.BoxGeometry(1.5, 2, 0.8); // Width, Height, Depth
    const bodyEdges = new THREE.EdgesGeometry(bodyGeometry);
    const bodyLines = new THREE.LineSegments(
        bodyEdges,
        new THREE.LineBasicMaterial({ color: 0xffffff })
    );

    // Two parallel lines on the top face (horizontal)
    const topLinesGeometry = new THREE.BufferGeometry();
    const vertices = new Float32Array([
        -0.4, 1, 0.4,  -0.4, 1, -0.4,  // Left Line
         0.4, 1, 0.4,   0.4, 1, -0.4   // Right Line
    ]);
    topLinesGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    const topLines = new THREE.LineSegments(
        topLinesGeometry,
        new THREE.LineBasicMaterial({ color: 0xffffff })
    );

    // Handle (two parallel rods + top bar)
    const handleGeometry = new THREE.BufferGeometry();
    const handleVertices = new Float32Array([
        // Left vertical rod
        -0.5, 1.2, 0.3,  -0.5, 1.7, 0.3,
        // Right vertical rod
         0.5, 1.2, 0.3,   0.5, 1.7, 0.3,
        // Connecting top bar
        -0.5, 1.7, 0.3,   0.5, 1.7, 0.3
    ]);
    handleGeometry.setAttribute('position', new THREE.BufferAttribute(handleVertices, 3));
    const handle = new THREE.LineSegments(
        handleGeometry,
        new THREE.LineBasicMaterial({ color: 0xffffff })
    );

    // Side straps
    const strapGeometry = new THREE.BoxGeometry(0.1, 1.5, 0.8);
    const strapEdges = new THREE.EdgesGeometry(strapGeometry);
    
    const leftStrap = new THREE.LineSegments(
        strapEdges,
        new THREE.LineBasicMaterial({ color: 0xffffff })
    );
    leftStrap.position.set(-0.8, 0.25, 0);

    const rightStrap = leftStrap.clone();
    rightStrap.position.set(0.8, 0.25, 0);

    group.add(
        bodyLines,
        topLines,
        handle,
        leftStrap,
        rightStrap
    );
    
    return group;
})();



        scene.add(sphere, cameraWireframe, suitcaseWireframe);

        // Physics setup
        let velocity = 2;
        const gravity = 9.8;
        const bounceFactor = 1.0;
        const floorLevel = 1;
        const peakHeight = 5;
        let currentHeight = peakHeight;
        let bounceCount = 0;

        camera.position.set(8, 5, 10);
        camera.lookAt(0, 2, 0);

        let lastTime = 0;
        function animate(timestamp) {
            requestAnimationFrame(animate);
            
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            // Physics update
            velocity -= gravity * deltaTime;
            currentHeight += velocity * deltaTime;

            // Bounce logic
            if(currentHeight < floorLevel) {
                currentHeight = floorLevel;
                velocity = Math.abs(velocity) * bounceFactor;
                bounceCount++;
            }

            // Transition parameters
            const progress = (currentHeight - floorLevel) / (peakHeight - floorLevel);
            const sphereScale = Math.max(0.1, 1 - progress);
            const objectScale = progress * 1.3;
            const easeIn = progress * progress;
            const isCameraTurn = bounceCount % 2 === 0;

            // Update sphere
            sphere.position.y = currentHeight;
            sphere.scale.set(sphereScale, sphereScale, sphereScale);
            sphere.material.opacity = 1 - easeIn*2;
            sphere.rotation.y += deltaTime * (1-easeIn )* 10;
            // Update objects
            const updateObject = (obj, active) => {
                obj.position.copy(sphere.position);
                obj.visible = active;
                if(active) {
                    obj.scale.set(objectScale, objectScale, objectScale);
                    obj.traverse(child => {
                        if (child instanceof THREE.LineSegments) {
                            child.material.opacity = easeIn;
                        }
                    });
                    obj.rotation.y += deltaTime * easeIn * 5;
                } else {
                    obj.scale.set(0.001, 0.001, 0.001);
                }
            };

            updateObject(cameraWireframe, isCameraTurn);
            updateObject(suitcaseWireframe, !isCameraTurn);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate(0);
    </script>
</body>
</html>